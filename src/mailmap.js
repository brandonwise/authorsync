/**
 * Mailmap generator - creates .mailmap file content from identity clusters
 */

import { isNoReply, emailDomain } from './matcher.js';

/**
 * @typedef {Object} Author
 * @property {string} name - Author name
 * @property {string} email - Author email
 * @property {number} commits - Number of commits
 */

/**
 * @typedef {Object} IdentityCluster
 * @property {Author} canonical - The canonical identity
 * @property {Author[]} aliases - Other identities
 * @property {number} confidence - Confidence score
 * @property {string} reason - Clustering reason
 */

/**
 * Score an identity to determine if it should be canonical
 * Higher score = better canonical identity
 * @param {Author} author - Author identity
 * @returns {number} Score
 */
function scoreIdentity(author) {
  let score = author.commits; // Base score is commit count

  // Penalize noreply emails
  if (isNoReply(author.email)) {
    score *= 0.3;
  }

  // Prefer company domains over free email
  const domain = emailDomain(author.email);
  const freeDomains = [
    'gmail.com',
    'yahoo.com',
    'hotmail.com',
    'outlook.com',
    'protonmail.com',
    'icloud.com',
    'me.com',
    'mac.com',
  ];
  if (!freeDomains.includes(domain)) {
    score *= 1.2;
  }

  // Prefer longer/more complete names
  const nameParts = author.name.trim().split(/\s+/);
  if (nameParts.length >= 2) {
    score *= 1.1;
  }

  // Penalize generic names
  const genericNames = ['root', 'admin', 'user', 'unknown', 'test'];
  if (genericNames.includes(author.name.toLowerCase())) {
    score *= 0.2;
  }

  return score;
}

/**
 * Select the best canonical identity from a cluster
 * @param {Author[]} identities - All identities in cluster
 * @returns {Author} Best canonical identity
 */
export function selectCanonical(identities) {
  if (identities.length === 0) {
    throw new Error('Cannot select canonical from empty list');
  }
  if (identities.length === 1) {
    return identities[0];
  }

  // Score each identity
  const scored = identities.map((identity) => ({
    identity,
    score: scoreIdentity(identity),
  }));

  // Sort by score descending
  scored.sort((a, b) => b.score - a.score);

  return scored[0].identity;
}

/**
 * Generate .mailmap file content from clusters
 * @param {IdentityCluster[]} clusters - Identity clusters
 * @param {Object} [options] - Generation options
 * @param {boolean} [options.comments=true] - Include comments explaining mappings
 * @param {boolean} [options.reselect=true] - Re-select canonical using scoring
 * @returns {string} Mailmap file content
 */
export function generateMailmap(clusters, options = {}) {
  const { comments = true, reselect = true } = options;
  const lines = [];

  if (comments) {
    lines.push('# .mailmap - Author identity mappings');
    lines.push('# Generated by authorsync');
    lines.push('# https://github.com/brandonwise/authorsync');
    lines.push('#');
    lines.push('# Format: Canonical Name <canonical@email> Alias Name <alias@email>');
    lines.push('#');
    lines.push('');
  }

  for (const cluster of clusters) {
    // Optionally re-select canonical based on scoring
    const allIdentities = [cluster.canonical, ...cluster.aliases];
    const canonical = reselect
      ? selectCanonical(allIdentities)
      : cluster.canonical;

    const aliases = allIdentities.filter(
      (a) => a.name !== canonical.name || a.email !== canonical.email
    );

    if (aliases.length === 0) continue;

    if (comments) {
      const totalCommits =
        canonical.commits + aliases.reduce((sum, a) => sum + a.commits, 0);
      lines.push(`# ${canonical.name} (${totalCommits} commits)`);
    }

    for (const alias of aliases) {
      // Full format: Canonical Name <canonical@email> Alias Name <alias@email>
      lines.push(
        `${canonical.name} <${canonical.email}> ${alias.name} <${alias.email}>`
      );
    }

    if (comments) {
      lines.push('');
    }
  }

  return lines.join('\n').trim() + '\n';
}

/**
 * Generate a simple list showing proposed mappings
 * @param {IdentityCluster[]} clusters - Identity clusters
 * @returns {string} Human-readable mapping list
 */
export function formatMappingSummary(clusters) {
  const lines = [];

  for (const cluster of clusters) {
    const allIdentities = [cluster.canonical, ...cluster.aliases];
    const canonical = selectCanonical(allIdentities);
    const aliases = allIdentities.filter(
      (a) => a.name !== canonical.name || a.email !== canonical.email
    );

    if (aliases.length === 0) continue;

    lines.push(`\n✓ ${canonical.name} <${canonical.email}>`);
    for (const alias of aliases) {
      lines.push(`  ← ${alias.name} <${alias.email}> (${alias.commits} commits)`);
    }
  }

  return lines.join('\n');
}

/**
 * Generate statistics about what mailmap would accomplish
 * @param {IdentityCluster[]} clusters - Identity clusters
 * @param {number} totalAuthors - Total number of authors
 * @returns {Object} Statistics
 */
export function generateStats(clusters, totalAuthors) {
  const affectedAliases = clusters.reduce(
    (sum, c) => sum + c.aliases.length,
    0
  );
  const affectedCommits = clusters.reduce(
    (sum, c) =>
      sum + c.aliases.reduce((aSum, alias) => aSum + alias.commits, 0),
    0
  );

  return {
    clustersFound: clusters.length,
    aliasesConsolidated: affectedAliases,
    authorsAfter: totalAuthors - affectedAliases,
    commitsAffected: affectedCommits,
    reductionPercent:
      totalAuthors > 0
        ? Math.round((affectedAliases / totalAuthors) * 100)
        : 0,
  };
}
